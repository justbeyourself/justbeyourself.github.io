

<head>
    <meta name="description" content="just be yourself.">
    <meta name="keywords" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content='linux常用命令 - 勇敢做自己' name='title' />
    <meta content='linux常用命令 - 勇敢做自己' name='og:title' />
    <title>linux常用命令 - 勇敢做自己</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;700&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
<link href='/images/favicon.png' rel='shortcut icon'>
<link href='/stylesheets/style.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css' />

<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

  <meta content='http://localhost:4000/posts/linux' property='og:url' />
  <meta content="  启动脚本  nohup  &amp;          curl        watch  tail 命令语法  vmstat  ifconfig 查看ip  scp远程传输  压缩解压  防火墙相关命令          防火..." property='og:description' />
  <meta content="article" property="og:type" />

<!-- - -->





</head>
<body class="lh-copy dark-gray pa0 f6 sans-serif animate-fade-in post-page">
    <header class="tl pv5 hero-gradient">
      <div id="canvas-container"></div>
      <div class="hero-content mw8 center ph3-ns ph2">
        <a href="http://localhost:4000" class="floating dib">
          <img src="/images/logo.png" alt="Home" width="80" height="90" class="br-100 pa2 bg-white-20 shadow-2">
        </a>
        <h1 class="f2 fw6 mb0 mt3 white">勇敢做自己</h1>
        <p class="f5 white-80 mt2">just be yourself.</p>
      </div>
    </header>
    
    <div class="mw8 center ph3-ns ph2 mt4 mb5">
      <div class="glass br3 overflow-hidden">
        <nav class="bb b--black-05 pv3 tc ink-nav" aria-label="Main">
          <a class="link-underline dib mh3 pv1 fw5 ink-blue" href="/">文章</a>
          <a class="link-underline dib mh3 pv1 fw5 ink-blue" href="/about">关于我</a>
        </nav>

        <main class="tl f5 relative pa4 pa5-ns ink-content">
        
          <div class="mb4">
            <div class="fw600 light-silver mt1">01 May 2018</div>
            <h1 class="ttu f2 mt0 lh-title cb mb2 blue">
              
              linux常用命令
            </h1>
            
          </div>
        
        <div class="markdown-body">
          <ul id="markdown-toc">
  <li><a href="#启动脚本" id="markdown-toc-启动脚本">启动脚本</a></li>
  <li><a href="#nohup" id="markdown-toc-nohup">nohup</a></li>
  <li><a href="#" id="markdown-toc-">&amp;</a>    <ul>
      <li><a href="#curl" id="markdown-toc-curl">curl</a></li>
    </ul>
  </li>
  <li><a href="#watch" id="markdown-toc-watch">watch</a></li>
  <li><a href="#tail-命令语法" id="markdown-toc-tail-命令语法">tail 命令语法</a></li>
  <li><a href="#vmstat" id="markdown-toc-vmstat">vmstat</a></li>
  <li><a href="#ifconfig-查看ip" id="markdown-toc-ifconfig-查看ip">ifconfig 查看ip</a></li>
  <li><a href="#scp远程传输" id="markdown-toc-scp远程传输">scp远程传输</a></li>
  <li><a href="#压缩解压" id="markdown-toc-压缩解压">压缩解压</a></li>
  <li><a href="#防火墙相关命令" id="markdown-toc-防火墙相关命令">防火墙相关命令</a>    <ul>
      <li><a href="#防火墙的开启关闭禁用命令" id="markdown-toc-防火墙的开启关闭禁用命令">防火墙的开启、关闭、禁用命令</a></li>
      <li><a href="#使用firewall-cmd配置端口" id="markdown-toc-使用firewall-cmd配置端口">使用firewall-cmd配置端口</a></li>
    </ul>
  </li>
  <li><a href="#查看历史记录" id="markdown-toc-查看历史记录">查看历史记录</a></li>
  <li><a href="#查看linux版本号" id="markdown-toc-查看linux版本号">查看linux版本号</a></li>
  <li><a href="#less-命令乱码" id="markdown-toc-less-命令乱码">less 命令乱码</a></li>
  <li><a href="#串口相关指令" id="markdown-toc-串口相关指令">串口相关指令</a></li>
  <li><a href="#查看文件大小" id="markdown-toc-查看文件大小">查看文件大小</a>    <ul>
      <li><a href="#列出当前文件夹下所有文件对应的大小" id="markdown-toc-列出当前文件夹下所有文件对应的大小">列出当前文件夹下所有文件对应的大小</a></li>
      <li><a href="#列出当前目录下每个文件的大小同时也会给出当前目录下所有文件大小总和" id="markdown-toc-列出当前目录下每个文件的大小同时也会给出当前目录下所有文件大小总和">列出当前目录下每个文件的大小，同时也会给出当前目录下所有文件大小总和</a></li>
    </ul>
  </li>
  <li><a href="#netstat-是一款命令行工具可用于列出系统上所有的网络套接字连接情况" id="markdown-toc-netstat-是一款命令行工具可用于列出系统上所有的网络套接字连接情况">Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况</a>    <ul>
      <li><a href="#列出所有当前的连接" id="markdown-toc-列出所有当前的连接">列出所有当前的连接</a></li>
      <li><a href="#使用--t-选项列出-tcp-协议的连接" id="markdown-toc-使用--t-选项列出-tcp-协议的连接">使用 <strong>-t</strong> 选项列出 TCP 协议的连接</a></li>
      <li><a href="#使用--u-选项列出-udp-协议的连接" id="markdown-toc-使用--u-选项列出-udp-协议的连接">使用 <strong>-u</strong> 选项列出 UDP 协议的连接</a></li>
      <li><a href="#默认情况下-netstat-会通过反向域名解析技术查找每个-ip-地址对应的主机名这会降低查找速度如果你觉得-ip-地址已经足够而没有必要知道主机名就使用--n-选项禁用域名解析功能" id="markdown-toc-默认情况下-netstat-会通过反向域名解析技术查找每个-ip-地址对应的主机名这会降低查找速度如果你觉得-ip-地址已经足够而没有必要知道主机名就使用--n-选项禁用域名解析功能">默认情况下 netstat 会通过反向域名解析技术查找每个 IP 地址对应的主机名。这会降低查找速度。如果你觉得 IP 地址已经足够，而没有必要知道主机名，就使用 <strong>-n</strong> 选项禁用域名解析功能。</a></li>
      <li><a href="#只列出监听中的连接" id="markdown-toc-只列出监听中的连接">只列出监听中的连接</a></li>
    </ul>
  </li>
  <li><a href="#mysql" id="markdown-toc-mysql">mysql</a>    <ul>
      <li><a href="#连接" id="markdown-toc-连接">连接</a>        <ul>
          <li><a href="#本地" id="markdown-toc-本地">本地</a></li>
          <li><a href="#远程" id="markdown-toc-远程">远程</a></li>
        </ul>
      </li>
      <li><a href="#修改密码" id="markdown-toc-修改密码">修改密码</a></li>
    </ul>
  </li>
  <li><a href="#系统" id="markdown-toc-系统">系统</a>    <ul>
      <li><a href="#查看系统信息的shell脚本" id="markdown-toc-查看系统信息的shell脚本">查看系统信息的shell脚本</a></li>
      <li><a href="#看linux系统物理cpu个数" id="markdown-toc-看linux系统物理cpu个数">看linux系统物理cpu个数</a></li>
      <li><a href="#查看linux系统物理cpu的核数" id="markdown-toc-查看linux系统物理cpu的核数">查看linux系统物理cpu的核数</a></li>
      <li><a href="#查查看linux逻辑cpu数" id="markdown-toc-查查看linux逻辑cpu数">查查看linux逻辑cpu数</a></li>
      <li><a href="#是否为超线程" id="markdown-toc-是否为超线程">是否为超线程？</a></li>
      <li><a href="#查询内存情况" id="markdown-toc-查询内存情况">查询内存情况</a></li>
      <li><a href="#查看开放的端口" id="markdown-toc-查看开放的端口">查看开放的端口</a></li>
      <li><a href="#问题排查" id="markdown-toc-问题排查">问题排查</a></li>
    </ul>
  </li>
</ul>
<h2 id="启动脚本">启动脚本</h2>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="nv">server_name</span><span class="o">=</span><span class="s1">'test-kafka.jar'</span>
<span class="nb">echo</span> <span class="s2">"--------------------关闭中-----------------"</span>
<span class="nv">PROCESS</span><span class="o">=</span><span class="sb">`</span>ps -ef |grep java |grep -v grep|grep <span class="nv">$server_name</span>|awk <span class="s1">'{print $2}'</span><span class="sb">`</span>
<span class="k">for </span>i <span class="k">in</span> <span class="nv">$PROCESS</span>
<span class="k">do
  </span><span class="nb">echo</span> <span class="s2">"Kill the </span><span class="nv">$1</span><span class="s2"> process [ </span><span class="nv">$i</span><span class="s2"> ]"</span>
  <span class="nb">kill</span> -9 <span class="nv">$i</span>
<span class="k">done
</span><span class="nb">echo</span> <span class="s2">"-------------------关闭成功----------------"</span>
<span class="nb">echo</span> <span class="s2">"-------------------启动中------------------"</span>
nohup java -Xmx2048m -Xms1024m -Xss512k -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath<span class="o">=</span>../logs/heap_dump.bin -Djava.security.egd<span class="o">=</span>file:/dev/urandom -XX:-OmitStackTraceInFastThrow -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction<span class="o">=</span>75 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles<span class="o">=</span>10 -XX:GCLogFileSize<span class="o">=</span>100M -jar <span class="nv">$server_name</span> &amp;
<span class="nb">echo</span> <span class="s2">"-------------------启动成功-----------------"</span>
<span class="nb">echo</span> <span class="nv">$!</span>
</code></pre>
</div>

<h2 id="nohup">nohup</h2>

<p>不挂断地运行命令。
语法：<code class="highlighter-rouge">nohup Command [ Arg … ] [ &amp; ]</code></p>

<p>无论是否将 <code class="highlighter-rouge">nohup</code> 命令的输出重定向到终端，输出都将附加到当前目录的 <code class="highlighter-rouge">nohup.out</code> 文件中。</p>

<p>如果当前目录的 <code class="highlighter-rouge">nohup.out</code> 文件不可写，输出重定向到 <code class="highlighter-rouge">$HOME/nohup.out</code> 文件中。</p>

<p>如果没有文件能创建或打开以用于追加，那么 <code class="highlighter-rouge">Command</code> 参数指定的命令不可调用。</p>

<h2>&amp;</h2>

<p>用途：在后台运行。一般两个一起用：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>nohup <span class="nb">command</span> &amp;
</code></pre>
</div>

<h3 id="curl">curl</h3>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>curl -H <span class="s2">"Content-Type:application/json"</span> -X POST --data <span class="s1">'{"deviceNo": "123213123","epcs": ["E10012546220","E10012546220"]}'</span> http://10.172.0.220:8001/localserver/securitydoor/epc/alarm
</code></pre>
</div>

<h2 id="watch">watch</h2>

<p><code class="highlighter-rouge">watch</code> 命令会每隔两秒执行一次该该命令，并全屏输出执行结果。</p>

<p>Options:</p>
<ul>
  <li><code class="highlighter-rouge">-b, --beep</code>             beep if command has a non-zero exit</li>
  <li><code class="highlighter-rouge">-c, --color</code>            interpret ANSI color and style sequences</li>
  <li><code class="highlighter-rouge">-d, --differences[=&lt;permanent&gt;]</code> highlight changes between updates</li>
  <li><code class="highlighter-rouge">-e, --errexit</code>          exit if command has a non-zero exit</li>
  <li><code class="highlighter-rouge">-g, --chgexit</code>          exit when output from command changes</li>
  <li><code class="highlighter-rouge">-n, --interval &lt;secs&gt;</code>  seconds to wait between updates</li>
  <li><code class="highlighter-rouge">-p, --precise</code>          attempt run command in precise intervals</li>
  <li><code class="highlighter-rouge">-t, --no-title</code>         turn off header</li>
  <li><code class="highlighter-rouge">-x, --exec</code>             pass command to exec instead of “sh -c”</li>
  <li><code class="highlighter-rouge">-h, --help</code>             display this help and exit</li>
  <li><code class="highlighter-rouge">-v, --version</code>          output version information and exit</li>
</ul>

<h2 id="tail-命令语法">tail 命令语法</h2>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>tail <span class="o">[</span> -f <span class="o">]</span> <span class="o">[</span> -c Number | -n Number | -m Number | -b Number | -k Number <span class="o">]</span> <span class="o">[</span> File <span class="o">]</span>
</code></pre>
</div>

<p>参数解释：</p>
<ul>
  <li><code class="highlighter-rouge">-f</code> 该参数用于监视 File 文件增长。</li>
  <li><code class="highlighter-rouge">-c Number</code> 从 Number 字节位置读取指定文件。</li>
  <li><code class="highlighter-rouge">-n Number</code> 从 Number 行位置读取指定文件。</li>
  <li><code class="highlighter-rouge">-m Number</code> 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定 <code class="highlighter-rouge">-c</code> 参数，可能导致截断，但使用 <code class="highlighter-rouge">-m</code> 则会避免该问题。</li>
  <li><code class="highlighter-rouge">-b Number</code> 从 Number 表示的 512 字节块位置读取指定文件。</li>
  <li><code class="highlighter-rouge">-k Number</code> 从 Number 表示的 1KB 块位置读取指定文件。</li>
  <li><code class="highlighter-rouge">File</code> 指定操作的目标文件名称。</li>
</ul>

<p>上述命令中，都涉及到 number，假设不指定，默认显示 10 行。Number 前面可使用正负号，表示该偏移从顶部还是从尾部開始计算。</p>

<p><code class="highlighter-rouge">tail</code> 可运行文件一般在 <code class="highlighter-rouge">/usr/bin/</code> 以下。</p>

<p>tail -20f |grep ‘xxxx’   过滤信息
ps -ef|grep java 查看java 进程</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
### grep



</code></pre>
</div>
<ol>
  <li>‘grep’ OR
这里有4种方法可以实现‘grep’ OR 。我更倾向于第三种。</li>
</ol>

<table>
  <tbody>
    <tr>
      <td>1.1 ‘gerp’ OR 使用 ‘</td>
      <td>’</td>
    </tr>
    <tr>
      <td>如果你使用 ‘grep’ 命令不带任何选项，你需要使用 ‘</td>
      <td>’ 来作OR条件的分隔符。</td>
    </tr>
  </tbody>
</table>

<p>grep ‘pattern1|pattern2’ filename</p>

<table>
  <tbody>
    <tr>
      <td>比如，你想打印出employee.txt中的Tach和Sales。没有 ‘\’ 在 ‘</td>
      <td>’ 之前，下面的命令是没有用的。</td>
    </tr>
  </tbody>
</table>

<p>$ grep ‘Tech|Sales’ employee.txt 100 Thomas Manager Sales $5,000 200 Jason Developer Technology $5,500 300 Raj Sysadmin Technology $7,000 500 Randy Manager Sales $6,000</p>

<p>1.2 ‘gerp’ OR 使用 ‘-E’
‘grep’ ‘-E’ 选项表示使用扩展的正则表达式。如果你使用 ‘grep’ 命令时带 ‘-E’，你只需要用途 ‘|’ 来分隔OR条件。</p>

<table>
  <tbody>
    <tr>
      <td>grep -E ‘pattern1</td>
      <td>pattern2’ filename</td>
    </tr>
  </tbody>
</table>

<p>打印出employee.txt中的Tach和Sales：</p>

<table>
  <tbody>
    <tr>
      <td>$ grep -E ‘Tech</td>
      <td>Sales’ employee.txt 100 Thomas Manager Sales $5,000 200 Jason Developer Technology $5,500 300 Raj Sysadmin Technology $7,000 500 Randy Manager Sales $6,000</td>
    </tr>
  </tbody>
</table>

<p>1.3 ‘gerp’ OR 使用 ‘egrep’
‘egrep’ 就是 ‘grep -E’。所以</p>

<table>
  <tbody>
    <tr>
      <td>$ egrep ‘Tech</td>
      <td>Sales’ employee.txt 100 Thomas Manager Sales $5,000 200 Jason Developer Technology $5,500 300 Raj Sysadmin Technology $7,000 500 Randy Manager Sales $6,000</td>
    </tr>
  </tbody>
</table>

<p>1.4 ‘gerp’ OR 使用 ‘grep -e’
使用 ‘grep -e’ 选项你仅可以传递一个参数。在一个命令中使用多个 ‘-e’ 选项可以指定多个OR条件。Example:</p>

<p>$ grep -e Tech -e Sales employee.txt 100 Thomas Manager Sales $5,000 200 Jason Developer Technology $5,500 300 Raj Sysadmin Technology $7,000 500 Randy Manager Sales $6,000</p>

<ol>
  <li>‘grep’ AND
‘grep’ 命令没有 AND 操作符。但是，上文说了，我们可以模拟它。</li>
</ol>

<p>2.1 ‘grep’ AND 使用 ‘-E pattern1.<em>pattern2’
grep -E ‘pattern1.</em>pattern2’ filename grep -E ‘pattern1.<em>pattern2|pattern2.</em>pattern1’ filename</p>

<p>Example:</p>

<p>$ grep -E ‘Dev.*Tech’ employee.txt 200 Jason Developer Technology $5,500</p>

<p>2.2 ‘grep’ AND 使用多个 ‘grep’ 命令
你还可以使用多个 ‘grep’ 命令加管道(pipe)的方式来实现 AND 操作。</p>

<table>
  <tbody>
    <tr>
      <td>grep -E ‘pattern1’ filename</td>
      <td>grep -E ‘pattern2’</td>
    </tr>
  </tbody>
</table>

<p>Example:</p>

<table>
  <tbody>
    <tr>
      <td>$ grep Manager employee.txt</td>
      <td>grep Sales 100 Thomas Manager Sales $5,000 500 Randy Manager Sales $6,000</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>‘grep’ NOT
使用 ‘grep -v’ 你可以模拟NOT操作。</li>
</ol>

<p>-v, –invert-match
Invert the sense of matching, to select non-matching lines.</p>

<p>使用 ‘-v’ 选项来反向匹配，选择不匹配的行。</p>

<p>grep -v ‘pattern1’ filename</p>

<div class="highlighter-rouge"><pre class="highlight"><code>


## jps 命令

</code></pre>
</div>
<p>jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。非常简单实用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    命令格式：jps [options ] [ hostid ]

    [options]选项： -q：仅输出VM标识符，不包括classname,jar name,arguments in main method -m：输出main method的参数 -l：输出完全的包名，应用主类名，jar的完全路径名 -v：输出jvm参数 -V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 -Joption：传递参数到vm,例如:-J-Xms512m

 [hostid]：
</code></pre>
</div>

<p>[protocol:][[//]hostname][:port][/servername]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>命令的输出格式 ： lvmid [ [ classname| JARfilename | "Unknown"] [ arg* ] [ jvmarg* ] ] ```
</code></pre>
</div>

<h2 id="vmstat">vmstat</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:

root@ubuntu:~# vmstat 2 1
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 1  0      0 3498472 315836 3819540    0    0     0     1    2    0  0  0 100  0
2表示每个两秒采集一次服务器状态，1表示只采集一次。

实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如:

复制代码
root@ubuntu:~# vmstat 2  
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 1  0      0 3499840 315836 3819660    0    0     0     1    2    0  0  0 100  0
 0  0      0 3499584 315836 3819660    0    0     0     0   88  158  0  0 100  0
 0  0      0 3499708 315836 3819660    0    0     0     2   86  162  0  0 100  0
 0  0      0 3499708 315836 3819660    0    0     0    10   81  151  0  0 100  0
 1  0      0 3499732 315836 3819660    0    0     0     2   83  154  0  0 100  0
复制代码
这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。

好了，命令介绍完毕，现在开始实战讲解每个参数的意思。

r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

free   空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。

buff   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M

cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)

si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。

so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。

bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒

bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

in 每秒CPU的中断次数，包括时间中断

cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。

us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。

sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

wt 等待IO CPU时间。
</code></pre>
</div>
<h2 id="ifconfig-查看ip">ifconfig 查看ip</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>ifconfig -a
</code></pre>
</div>

<h2 id="scp远程传输">scp远程传输</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>scp ymj.war root@192.168.70.200:/home



1．命令格式：

scp [参数] [原路径] [目标路径]

2．命令功能：

scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。

3．命令参数：

-1  强制scp命令使用协议ssh1  

-2  强制scp命令使用协议ssh2  

-4  强制scp命令只使用IPv4寻址  

-6  强制scp命令只使用IPv6寻址  

-B  使用批处理模式（传输过程中不询问传输口令或短语）  

-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  

-p 保留原文件的修改时间，访问时间和访问权限。  

-q  不显示传输进度条。  

-r  递归复制整个目录。  

-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   

-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   

-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  

-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    

-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     

-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   

-P port  注意是大写的P, port是指定数据传输用到的端口号   

-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
</code></pre>
</div>

<h2 id="压缩解压">压缩解压</h2>
<div class="highlighter-rouge"><pre class="highlight"><code>tar
  解包：tar zxvf filename.tar
  打包：tar czvf filename.tar dirname
gz命令
  解压1：gunzip filename.gz
  解压2：gzip -d filename.gz
  压缩：gzip filename
      .tar.gz 和  .tgz
      解压：tar zxvf filename.tar.gz
      压缩：tar zcvf filename.tar.gz dirname
      压缩多个文件：tar zcvf filename.tar.gz dirname1 dirname2 dirname3.....
bz2命令
  解压1：bzip2 -d filename.bz2
  解压2：bunzip2 filename.bz2
  压缩：bzip2 -z filename
        .tar.bz2

       解压：tar jxvf filename.tar.bz2
       压缩：tar jcvf filename.tar.bz2 dirname
bz命令
    解压1：bzip2 -d filename.bz
    解压2：bunzip2 filename.bz
         .tar.bz
       解压：tar jxvf filename.tar.bz
z命令
    解压：uncompress filename.z
    压缩：compress filename
        .tar.z
          解压：tar zxvf filename.tar.z
          压缩：tar zcvf filename.tar.z dirname
zip命令
    
    解压：unzip filename.zip
    压缩：zip filename.zip dirname
</code></pre>
</div>
<h2 id="防火墙相关命令">防火墙相关命令</h2>

<h3 id="防火墙的开启关闭禁用命令">防火墙的开启、关闭、禁用命令</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>（1）设置开机启用防火墙：systemctl enable firewalld.service
（2）设置开机禁用防火墙：systemctl disable firewalld.service
（3）启动防火墙：systemctl start firewalld
（4）关闭防火墙：systemctl stop firewalld
（5）检查防火墙状态：systemctl status firewalld 
</code></pre>
</div>
<h3 id="使用firewall-cmd配置端口">使用firewall-cmd配置端口</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>（1）查看防火墙状态：firewall-cmd --state
（2）重新加载配置：firewall-cmd --reload
（3）查看开放的端口：firewall-cmd --list-ports
（4）开启防火墙端口：firewall-cmd --zone=public --add-port=9200/tcp --permanent
　　命令含义：
　　–zone #作用域
　　–add-port=9200/tcp #添加端口，格式为：端口/通讯协议
　　–permanent #永久生效，没有此参数重启后失效
　　注意：添加端口后，必须用命令firewall-cmd --reload重新加载一遍才会生效
（5）关闭防火墙端口：firewall-cmd --zone=public --remove-port=9200/tcp --permanent
</code></pre>
</div>

<h2 id="查看历史记录">查看历史记录</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>ctrl+r
</code></pre>
</div>

<h2 id="查看linux版本号">查看linux版本号</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>uname -a

cat /proc/version
</code></pre>
</div>

<h2 id="less-命令乱码">less 命令乱码</h2>
<div class="highlighter-rouge"><pre class="highlight"><code>export LESSCHARSET=utf-8
</code></pre>
</div>

<h2 id="串口相关指令">串口相关指令</h2>
<div class="highlighter-rouge"><pre class="highlight"><code>ls /sys/bus/usb/devices/

dmesg | grep ttyUSB

ls /dev/ttyUSB*

ls -l /sys/class/tty/ttyUSB*
</code></pre>
</div>

<h2 id="查看文件大小">查看文件大小</h2>
<h3 id="列出当前文件夹下所有文件对应的大小">列出当前文件夹下所有文件对应的大小</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>du -sh *
</code></pre>
</div>
<h3 id="列出当前目录下每个文件的大小同时也会给出当前目录下所有文件大小总和">列出当前目录下每个文件的大小，同时也会给出当前目录下所有文件大小总和</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>ls -lht
</code></pre>
</div>

<h2 id="netstat-是一款命令行工具可用于列出系统上所有的网络套接字连接情况">Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况</h2>

<h3 id="列出所有当前的连接">列出所有当前的连接</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -a
</code></pre>
</div>

<h3 id="使用--t-选项列出-tcp-协议的连接">使用 <strong>-t</strong> 选项列出 TCP 协议的连接</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -at
</code></pre>
</div>

<h3 id="使用--u-选项列出-udp-协议的连接">使用 <strong>-u</strong> 选项列出 UDP 协议的连接</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -au
</code></pre>
</div>

<h3 id="默认情况下-netstat-会通过反向域名解析技术查找每个-ip-地址对应的主机名这会降低查找速度如果你觉得-ip-地址已经足够而没有必要知道主机名就使用--n-选项禁用域名解析功能">默认情况下 netstat 会通过反向域名解析技术查找每个 IP 地址对应的主机名。这会降低查找速度。如果你觉得 IP 地址已经足够，而没有必要知道主机名，就使用 <strong>-n</strong> 选项禁用域名解析功能。</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -ant
</code></pre>
</div>

<h3 id="只列出监听中的连接">只列出监听中的连接</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>netstat -tnl
</code></pre>
</div>

<h2 id="mysql">mysql</h2>

<h3 id="连接">连接</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql -h主机地址 -P端口 -u用户名 -p密码
</code></pre>
</div>

<h4 id="本地">本地</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql -uxxx -pxxx
</code></pre>
</div>

<h4 id="远程">远程</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql -h10.4.73.1 -P3306 -uuser -ppassword
</code></pre>
</div>

<h3 id="修改密码">修改密码</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>mysqladmin -u用户名 -p旧密码 password 新密码
</code></pre>
</div>

<h2 id="系统">系统</h2>

<h3 id="查看系统信息的shell脚本">查看系统信息的shell脚本</h3>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>
<span class="c"># 输出Linux的系统版本信息</span>
<span class="nb">echo</span> <span class="s2">"Linux系统版本信息："</span>
cat /etc/<span class="k">*</span>-release | grep -w <span class="s2">"NAME</span><span class="se">\|</span><span class="s2">VERSION"</span>

<span class="c"># 输出CPU信息</span>
lscpu | grep <span class="s2">"CPU(s):"</span> | awk <span class="s1">'{if($2~/^[0-9]+$/) {gsub(/[^0-9]/,"",$2); print "总核数：" $2}}'</span>


<span class="c"># 输出内存信息</span>
free -m | awk <span class="s1">'/Mem/ {printf "内存大小：%.2fG\n", $2/1024}'</span>

<span class="c"># 输出磁盘信息</span>
df -h | awk <span class="s1">'/^\/dev/{print "磁盘总大小：" $2}'</span>

</code></pre>
</div>

<h3 id="看linux系统物理cpu个数">看linux系统物理cpu个数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l
</code></pre>
</div>

<h3 id="查看linux系统物理cpu的核数">查看linux系统物理cpu的核数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /proc/cpuinfo | grep "core id" | sort | uniq | wc -l
</code></pre>
</div>

<h3 id="查查看linux逻辑cpu数">查查看linux逻辑cpu数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /proc/cpuinfo | grep "processor" | sort | uniq | wc -l
</code></pre>
</div>

<h3 id="是否为超线程">是否为超线程？</h3>

<p>如果有两个逻辑CPU具有相同的”core id”，那么超线程是打开的。或者siblings数目比cpu cores数目大。</p>

<p>每个物理CPU中逻辑CPU(可能是core, threads或both)的个数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat /proc/cpuinfo | grep "siblings"
</code></pre>
</div>

<h3 id="查询内存情况">查询内存情况</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>free 
单位kb

free -m
单位 M

free -h
单位G

</code></pre>
</div>

<h3 id="查看开放的端口">查看开放的端口</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>
</code></pre>
</div>

<h3 id="问题排查">问题排查</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>线上问题排查，以下场景，你遇到过吗？
 
一、了解机器连接数情况
问题：1.2.3.4的sshd的监听端口是22，如何统计1.2.3.4的sshd服务各种连接状态(TIME_WAIT/ CLOSE_WAIT/ ESTABLISHED)的连接数。
 
常见方法：
netstat -n | grep 1.2.3.4:22 | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’
netstat -lnpta | grep ssh | egrep “TIME_WAIT | CLOSE_WAIT | ESTABLISHED”
n [仅限于阿里云]
 
说明：netstat是追查网络连接问题常用工具，和grep/awk结合更是神器，当然如果在阿里云上，还有更方便的方法。
 
二、从已经备份好的日志中查询数据
问题：从已备份的suyun.2022-06-26.log.bz2日志中，找出包含关键字1.2.3.4的日志有多少条。
 
常见方法：
bzcat suyun.2022-06-26.log.bz2 | grep '1.2.3.4' | wc -l
bzgrep '1.2.3.4' suyun.2022-06-26.log.bz2 | wc -l
less suyun.2022-06-26.log.bz2 | grep '10.37.9.11' | wc -l
 
说明：线上日志文件一般以bz2 压缩之后保留，如果解压查询，非常耗空间与时间，bzcat和bzgrep是研发同学必须掌握的工具。
 
三、备份服务的技巧
问题：打包备份/opt/web/suyun_web目录，排除掉目录中的logs和目录，打包好的文件存放在/opt/backup目录下。
 
常见方法：
tar -zcvf /opt/backup/shenjian.tar.gz \
    -exclude /opt/web/suyun_web/logs \
    /opt/web/suyun_web
 
说明：这个命令线上应用较为频繁，在项目需要打包迁移时，常常需要排除掉日志目录，exclude是需要掌握的参数。
 
四、查询线程数
问题：查询服务器运行服务的总线程数，当机器线程数超报警阀值时，能快速查出相关进程及线程信息。
 
参考答案：
ps -eLf | wc -l
pstree -p | wc -l
 
五、磁盘报警，清空最大文件
问题：找出服务器上，某个正在运行的tomcat产生的大量异常日志，找出该文件，并释放空间。不妨设该文件包含log关键字，并且大于1G。
 
常见方法：
第一步，找到该文件
find / -type f -name "*log*" | xargs ls -lSh | more 
du -a / | sort -rn | grep log | more
find / -name '*log*' -size +1000M -exec du -h {} \;
 
第二步，将文件清空
假设找到的文件为a.log
正确的情况方式应该为：
echo ""&gt;a.log
文件空间会立刻释放。

很多同学会使用：
rm -rf a.log
这样文件虽然删除，但是因tomcat服务仍在运行，空间不会立刻释放，需要重启tomcat才能将空间释放。
 
六、显示文件，过滤注释
问题：显示server.conf 文件，屏蔽掉#号开头的注释行
 
常见方法：
sed -n '/^[#]/!p' server.conf
sed -e '/^#/d' server.conf
grep -v "^#" server.conf
 
七、磁盘IO异常排查
问题：磁盘IO异常如何排查，类似写入慢或当前使用率较高，请查出导致磁盘IO异常高的进程ID。
 
常见方法：
第一步：
iotop -o
查看当前正在写磁盘操作的所有进程ID信息。

第二步：如果此时各项写入指标都很低，基本没有大的写入操作，则需要排查磁盘自身。可以查看系统
dmesg
或
cat /var/log/message
看看是否有相关的磁盘异常报错，同时可以在写入慢的磁盘上touch一个空文件看看，是否磁盘故障导致无法写入。
</code></pre>
</div>



        </div>
        <div class="mt5 mb4 bt b--black-05 pt4">
  <p class="f6 gray italic tc">Thanks for reading! — muan</p>
</div>

      </main>
      <section class="bt b--black-05 pv4 flex justify-between">
  
    <a href="http://localhost:4000/posts/leaveHome" class="link blue hover-mid-gray fw6">
      ← 离乡
    </a>
  
  
    <a href="http://localhost:4000/posts/git" class="link blue hover-mid-gray fw6">
      Git 常用命令 →
    </a>
  
</section>
    </div>
      <footer class="pv4 tc silver f6">
        <p class="mb2">just be yourself and one day you will find someone who loves you for everything you are.</p>
        <p>© 2025 勇敢做自己. Built with Jekyll & ❤️</p>
      </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      (function() {
        const container = document.getElementById('canvas-container');
        if (!container) return;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        container.appendChild(renderer.domElement);

        // Starfield Creation
        function createStarfield(count, size, color, spread) {
          const geometry = new THREE.BufferGeometry();
          const vertices = [];
          for (let i = 0; i < count; i++) {
            vertices.push(THREE.MathUtils.randFloatSpread(spread));
            vertices.push(THREE.MathUtils.randFloatSpread(spread));
            vertices.push(THREE.MathUtils.randFloatSpread(spread));
          }
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          const material = new THREE.PointsMaterial({ 
            color: color, 
            size: size, 
            transparent: true, 
            opacity: Math.random() * 0.5 + 0.5,
            blending: THREE.AdditiveBlending 
          });
          return new THREE.Points(geometry, material);
        }

        const stars1 = createStarfield(1500, 2, 0xffffff, 2000);
        const stars2 = createStarfield(1000, 1.5, 0x4488ff, 2000);
        const stars3 = createStarfield(500, 3, 0xffaa44, 2000);
        
        scene.add(stars1);
        scene.add(stars2);
        scene.add(stars3);

        // Earth & Moon
        const textureLoader = new THREE.TextureLoader();
        
        // Earth
        const earthGeometry = new THREE.SphereGeometry(200, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
          map: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg'),
          specularMap: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg'),
          normalMap: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
          normalScale: new THREE.Vector2(0.85, 0.85),
          shininess: 10
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(400, 0, 0);
        scene.add(earth);

        // Clouds
        const cloudGeometry = new THREE.SphereGeometry(205, 64, 64);
        const cloudMaterial = new THREE.MeshLambertMaterial({
          map: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png'),
          transparent: true,
          opacity: 0.4
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        earth.add(clouds);

        // Moon
        const moonGeometry = new THREE.SphereGeometry(50, 32, 32);
        const moonMaterial = new THREE.MeshPhongMaterial({
          map: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg'),
          shininess: 0
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        scene.add(moon);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(500, 300, 500);
        scene.add(sunLight);

        camera.position.z = 1000;

        let moonAngle = 0;

        function animate() {
          requestAnimationFrame(animate);
          
          stars1.rotation.y += 0.0001;
          stars2.rotation.y -= 0.00015;
          
          // Earth Animation
          earth.rotation.y += 0.002;
          clouds.rotation.y += 0.001;

          // Moon Animation
          moonAngle += 0.005;
          moon.position.x = earth.position.x + Math.cos(moonAngle) * 500;
          moon.position.z = earth.position.z + Math.sin(moonAngle) * 500;
          moon.rotation.y += 0.005;
          
          renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
          camera.aspect = container.offsetWidth / container.offsetHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.offsetWidth, container.offsetHeight);
        });

        animate();
      })();

      // Mouse Trail Effect
      (function() {
        let lastMouseX = 0;
        let lastMouseY = 0;
        const starColors = ['#fff', '#667eea', '#764ba2', '#a0aec0'];

        document.addEventListener('mousemove', (e) => {
          const distance = Math.sqrt(Math.pow(e.clientX - lastMouseX, 2) + Math.pow(e.clientY - lastMouseY, 2));
          
          if (distance > 10) {
            createStar(e.clientX, e.clientY);
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          }
        });

        function createStar(x, y) {
          const star = document.createElement('div');
          star.className = 'star-particle';
          
          const size = Math.random() * 6 + 2;
          const color = starColors[Math.floor(Math.random() * starColors.length)];
          
          star.style.width = `${size}px`;
          star.style.height = `${size}px`;
          star.style.left = `${x}px`;
          star.style.top = `${y}px`;
          star.style.background = color;
          star.style.boxShadow = `0 0 ${size * 2}px ${size / 2}px ${color}`;
          
          document.body.appendChild(star);
          
          setTimeout(() => {
            star.remove();
          }, 1000);
        }
      })();
    </script>
</body>
</html>