---
layout: post
title: OnJava8笔记
date: 2019-01-01
tags: [语言]
comments: true
toc: false
---

* content
{:toc}

>《On Java 8》中文版，是事实上的《Java 编程思想》第5版。
>
>[on java 8](https://lingcoder.github.io/OnJava8/#/sidebar)

# [第一章 对象的概念](https://lingcoder.github.io/OnJava8/#/book/01-What-is-an-Object?id=第一章-对象的概念)

万物皆对象

抽象、封装、继承、多态

面向过程程序包含数据定义和函数调用。要找到程序的意图，你必须要在脑中建立一个模型，弄清函数调用和更底层的概念。这些程序令人困扰，因为它们的表示更多地面向计算机而不是我们要解决的问题，这就是我们在设计程序时需要中间表示的原因。

面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构。

设计良好的java程序更容易被人阅读理解。



# [第二章 安装Java和本书用例](https://lingcoder.github.io/OnJava8/#/book/02-Installing-Java-and-the-Book-Examples?id=第二章-安装java和本书用例)

# [第三章 万物皆对象](https://lingcoder.github.io/OnJava8/#/book/03-Objects-Everywhere?id=第三章-万物皆对象)

java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽然万物皆可为对象，但我们实际操纵的标识符实际上指示对象的“引用”。

new 关键字：创建一个新的对象实例。

1. **寄存器**（Registers）最快的存储区域，位于 CPU 内部 [^2](https://lingcoder.github.io/OnJava8/#/大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。)。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。
2. **栈内存**（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。基本类型存在栈内存。
3. **堆内存**（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 `new` 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
4. **常量存储**（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 [^3](https://lingcoder.github.io/OnJava8/#/一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。)。
5. **非 RAM 存储**（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

### [基本类型的存储](https://lingcoder.github.io/OnJava8/#/book/03-Objects-Everywhere?id=基本类型的存储)

boolean、char、byte、short、int、long、float、double

Java 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。 这个变量直接存储"值"，并置于栈内存中，因此更加高效。

我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 `new` 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。

面向对象编程可以总结为：向对象发送消息。

类是对象的外观及行为方式的描述。

**static** 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。

## 何为对象引用，值传递？还是引用传递？

[java都是值传递](https://juejin.im/post/5bce68226fb9a05ce46a0476)



# [第四章 运算符](https://lingcoder.github.io/OnJava8/#/book/04-Operators?id=第四章-运算符)



对于前递增和前递减（++a，--a），会先进行运算，再返回值；对于后递增和后递减（++a，--a），会先返回值，再进行运算。



## Integer == 问题

 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 `==` 和 `!=` 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码）。



# [第五章 控制流](https://lingcoder.github.io/OnJava8/#/book/05-Control-Flow?id=第五章-控制流)

# [第六章 初始化和清理](https://lingcoder.github.io/OnJava8/#/book/06-Housekeeping?id=第六章-初始化和清理)



